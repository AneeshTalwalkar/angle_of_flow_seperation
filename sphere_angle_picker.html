<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Seperation angle finder</title>
<style>
  :root{--bg:#0f172a;--card:#0b1220;--accent:#60a5fa;--muted:#94a3b8}
  html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial}
  body{display:flex;gap:12px;background:linear-gradient(180deg,#071028 0%, #071b2c 100%);color:#e6eef8;padding:12px}
  .sidebar{width:320px;min-width:240px;background:var(--card);border-radius:10px;padding:14px;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
  .main{flex:1;display:flex;align-items:stretch}
  canvas{background:#111827;border-radius:8px;display:block;max-width:100%;max-height:calc(100vh - 36px);cursor:crosshair}
  h1{font-size:16px;margin:0 0 8px}
  label{display:block;margin-bottom:8px}
  input[type=file]{display:block}
  button{background:transparent;border:1px solid rgba(255,255,255,0.08);color:var(--accent);padding:8px 10px;border-radius:6px;margin:6px 6px 6px 0}
  .muted{color:var(--muted);font-size:13px}
  .points{margin-top:8px}
  .point-row{display:flex;justify-content:space-between;padding:6px 4px;border-radius:6px}
  .controls{margin-top:12px}
  .hint{font-size:13px;color:var(--muted);margin-top:8px}
  .stat{margin-top:10px;padding:8px;border-radius:6px;background:rgba(255,255,255,0.02)}
  .warning{color:#ffb4b4}
  footer{font-size:12px;color:var(--muted);margin-top:12px}
</style>
</head>
<body>
  <div class="sidebar">
    <h1>Angle of flow seperation</h1>
    <div class="muted">Upload an image containing a spherical object. Zoom/pan to click precisely.</div>

    <label>Image <input id="file" type="file" accept="image/*"></label>
    <div class="controls">
      <button id="undo">Undo last point</button>
      <button id="clear">Clear points</button>
      <button id="resetView">Reset view</button>
      <button id="download">Download annotated image</button>
    </div>

    <div class="points">
      <div class="muted">Clicked points (image pixels):</div>
      <div id="list"></div>
    </div>

    <div class="stat">Center: <span id="center">—</span></div>
    <div class="stat">Radius: <span id="radius">—</span></div>
    <div class="stat">Angle between point 1 &amp; point 2 about center: <b id="angle">—</b></div>

    <div class="hint">
      Controls: Mouse wheel to zoom (cursor-focused). Hold <b>Space</b> or drag with middle mouse button to pan. Left-click to place a point. Right-click to remove last point.
    </div>
    <footer>Click exactly three points on the sphere's visible circumference. The app computes circle center and angle at center between points 1 & 2.</footer>
  </div>

  <div class="main">
    <canvas id="canvas"></canvas>
  </div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: false });
  const fileInput = document.getElementById('file');
  const listDiv = document.getElementById('list');
  const undoBtn = document.getElementById('undo');
  const clearBtn = document.getElementById('clear');
  const resetViewBtn = document.getElementById('resetView');
  const downloadBtn = document.getElementById('download');
  const centerEl = document.getElementById('center');
  const radiusEl = document.getElementById('radius');
  const angleEl = document.getElementById('angle');

  let img = new Image();
  let imgLoaded = false;

  // transform state
  let scale = 1;
  let tx = 0; // translate in px
  let ty = 0;
  const MIN_SCALE = 0.1;
  const MAX_SCALE = 40;

  // drawing state: points in image coordinates
  let points = [];
  let circle = null; // {cx,cy,r}

  // resize canvas to fill main area
  function resize() {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(600, Math.floor(rect.width * dpr));
    canvas.height = Math.max(400, Math.floor(rect.height * dpr));
    ctx.setTransform(1,0,0,1,0,0);
    ctx.imageSmoothingEnabled = true;
    render();
  }
  window.addEventListener('resize', resize);

  // file load
  fileInput.addEventListener('change', (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const url = URL.createObjectURL(f);
    img = new Image();
    img.onload = () => {
      imgLoaded = true;
      // center & fit image
      const rect = canvas.getBoundingClientRect();
      const w = rect.width, h = rect.height;
      scale = Math.min(w / img.width, h / img.height);
      if(scale === 0) scale = 1;
      // center image
      tx = (w - img.width * scale) / 2;
      ty = (h - img.height * scale) / 2;
      points = [];
      circle = null;
      updateInfo();
      render();
    };
    img.src = url;
  });

  // helpers: map client coords to canvas coords then to image coords
  function clientToCanvas(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const x = (clientX - rect.left) * (canvas.width / rect.width);
    const y = (clientY - rect.top) * (canvas.height / rect.height);
    return {x,y};
  }
  function canvasToImage(cx, cy) {
    // current transform applied when drawing: scale*dpr, and tx,ty scaled by dpr
    const dpr = window.devicePixelRatio || 1;
    const sx = scale * dpr;
    const ix = (cx - tx * dpr) / sx;
    const iy = (cy - ty * dpr) / sx;
    return {x: ix, y: iy};
  }

  function imageToCanvas(ix, iy) {
    const dpr = window.devicePixelRatio || 1;
    const sx = scale * dpr;
    const cx = ix * sx + tx * dpr;
    const cy = iy * sx + ty * dpr;
    return {x: cx, y: cy};
  }

  function render() {
    // clear
    ctx.fillStyle = '#0b1220';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    if (!imgLoaded) return;

    const dpr = window.devicePixelRatio || 1;
    // set transform so image and overlays drawn in image-coordinate space
    ctx.setTransform(scale * dpr, 0, 0, scale * dpr, tx * dpr, ty * dpr);
    // draw image
    ctx.drawImage(img, 0, 0);

    // draw overlays in image space
    // circle if available
    if (circle) {
      ctx.save();
      ctx.lineWidth = Math.max(2 / scale, 0.5);
      ctx.strokeStyle = 'rgba(96,165,250,0.9)';
      ctx.beginPath();
      ctx.arc(circle.cx, circle.cy, circle.r, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    // draw points
    points.forEach((p,i) => {
      ctx.save();
      ctx.beginPath();
      ctx.lineWidth = Math.max(3/scale, 0.5);
      ctx.strokeStyle = 'rgba(255,255,255,0.95)';
      ctx.fillStyle = i===0? 'rgba(16,185,129,0.95)' : (i===1? 'rgba(59,130,246,0.95)': 'rgba(234,88,12,0.95)');
      ctx.arc(p.x, p.y, Math.max(6/scale,3/scale), 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      // label
      ctx.font = `${Math.max(12/scale,8)}px sans-serif`;
      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.fillText(`${i+1}`, p.x + Math.max(8/scale,5/scale), p.y - Math.max(8/scale,5/scale));
      ctx.restore();
    });

    // draw crosshair at cursor? (not necessary)
  }

  // pointer handling for zoom/pan and clicks
  let isPanning = false;
  let lastPan = null;

  canvas.addEventListener('wheel', (e) => {
    if(!imgLoaded) return;
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    // pointer relative to canvas
    const {x: cx, y: cy} = clientToCanvas(e.clientX, e.clientY);
    const dpr = window.devicePixelRatio || 1;
    // image coords before
    const before = canvasToImage(cx, cy);

    // zoom factor
    const delta = -e.deltaY;
    const zoomFactor = Math.exp(delta * 0.0015);
    const newScale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, scale * zoomFactor));

    // adjust translate so that point under cursor remains fixed
    scale = newScale;
    const after = canvasToImage(cx, cy);
    // we need to move tx,ty so after == before -> (cx - tx')/s' = before.x -> tx' = cx - s'*before.x
    const s = scale; // new
    const dprInv = 1; // handled in canvasToImage
    // compute new tx,ty in CSS pixels (not dpr-scaled)
    const rectW = rect.width, rectH = rect.height;
    // convert back
    tx = (cx / (window.devicePixelRatio||1)) - s * before.x;
    ty = (cy / (window.devicePixelRatio||1)) - s * before.y;

    render();
  }, { passive: false });

  // panning with middle mouse or space + left drag
  canvas.addEventListener('pointerdown', (e) => {
    if (!imgLoaded) return;
    canvas.setPointerCapture(e.pointerId);
    const isMiddle = e.button === 1;
    const wantPan = isMiddle || e.spaceKey || e.shiftKey || e.altKey || e.ctrlKey || e.metaKey || e.getModifierState(' ');
    // we will use Space to pan; but older browsers don't set spaceKey. simplify: hold Space
    const spaceHeld = e.shiftKey || e.getModifierState && e.getModifierState('Space');

    // For simplicity: pan when middle button or space is held
    if (e.button === 1 || e.buttons === 4 || e.getModifierState('Space') || e.shiftKey) {
      isPanning = true;
      lastPan = {x: e.clientX, y: e.clientY};
      return;
    }

    // left click places a point
    if (e.button === 0) {
      const {x: cx, y: cy} = clientToCanvas(e.clientX, e.clientY);
      const imgPt = canvasToImage(cx, cy);
      // clamp within image
      imgPt.x = Math.max(0, Math.min(img.width, imgPt.x));
      imgPt.y = Math.max(0, Math.min(img.height, imgPt.y));
      points.push(imgPt);
      if (points.length > 3) points = points.slice(-3);
      computeCircleIfPossible();
      updateInfo();
      render();
    }

  });

  canvas.addEventListener('pointermove', (e) => {
    if (!imgLoaded) return;
    if (isPanning && lastPan) {
      const dx = e.clientX - lastPan.x;
      const dy = e.clientY - lastPan.y;
      // adjust tx,ty in CSS pixels
      tx += dx / (window.devicePixelRatio || 1);
      ty += dy / (window.devicePixelRatio || 1);
      lastPan = {x: e.clientX, y: e.clientY};
      render();
    }
  });
  canvas.addEventListener('pointerup', (e) => {
    canvas.releasePointerCapture && canvas.releasePointerCapture(e.pointerId);
    isPanning = false; lastPan = null;
  });
  // right click remove last point
  canvas.addEventListener('contextmenu', (e) => { e.preventDefault(); if (!imgLoaded) return; points.pop(); computeCircleIfPossible(); updateInfo(); render(); });

  // keyboard: Space for panning hint; prevent page scroll on space when canvas focused
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') { e.preventDefault(); }
  });

  undoBtn.addEventListener('click', () => { points.pop(); computeCircleIfPossible(); updateInfo(); render(); });
  clearBtn.addEventListener('click', () => { points = []; circle = null; updateInfo(); render(); });
  resetViewBtn.addEventListener('click', () => { if(!imgLoaded) return; const rect = canvas.getBoundingClientRect(); scale = Math.min(rect.width / img.width, rect.height / img.height) || 1; tx = (rect.width - img.width * scale)/2; ty = (rect.height - img.height * scale)/2; render(); });

  downloadBtn.addEventListener('click', () => {
    if (!imgLoaded) return;
    // create temporary canvas at image resolution
    const out = document.createElement('canvas');
    out.width = img.width; out.height = img.height;
    const oc = out.getContext('2d');
    oc.drawImage(img,0,0);
    // draw circle & points in image space
    if (circle) {
      oc.strokeStyle = 'rgba(96,165,250,1)'; oc.lineWidth = Math.max(3, 3);
      oc.beginPath(); oc.arc(circle.cx, circle.cy, circle.r, 0, Math.PI*2); oc.stroke();
    }
    points.forEach((p,i)=>{
      oc.fillStyle = 'white'; oc.beginPath(); oc.arc(p.x,p.y,6,0,Math.PI*2); oc.fill();
      oc.fillStyle='black'; oc.fillText(`${i+1}`, p.x+8, p.y-8);
    });
    const url = out.toDataURL('image/png');
    const a = document.createElement('a'); a.href = url; a.download = 'annotated.png'; a.click();
  });

  function updateInfo() {
    listDiv.innerHTML = '';
    points.forEach((p,i)=>{
      const row = document.createElement('div'); row.className = 'point-row';
      row.innerHTML = `<div>Point ${i+1}</div><div class='muted'>(${p.x.toFixed(1)}, ${p.y.toFixed(1)})</div>`;
      listDiv.appendChild(row);
    });
    if (circle) {
      centerEl.textContent = `${circle.cx.toFixed(2)}, ${circle.cy.toFixed(2)}`;
      radiusEl.textContent = `${circle.r.toFixed(2)} px`;
    } else { centerEl.textContent = '—'; radiusEl.textContent = '—'; }
    if (circle && points.length >= 2) {
      const v1 = {x: points[0].x - circle.cx, y: points[0].y - circle.cy};
      const v2 = {x: points[1].x - circle.cx, y: points[1].y - circle.cy};
      const dot = v1.x*v2.x + v1.y*v2.y;
      const mag1 = Math.hypot(v1.x, v1.y);
      const mag2 = Math.hypot(v2.x, v2.y);
      const cos = Math.max(-1, Math.min(1, dot / (mag1*mag2)));
      const ang = Math.acos(cos) * 180/Math.PI;
      angleEl.textContent = `${ang.toFixed(3)}°`;
    } else { angleEl.textContent = '—'; }
  }

  function computeCircleIfPossible() {
    circle = null;
    if (points.length < 3) return;
    // Use only first 3
    const [p1,p2,p3] = points.slice(0,3);
    // Compute circle through three points using perpendicular bisector intersection
    const x1=p1.x, y1=p1.y, x2=p2.x, y2=p2.y, x3=p3.x, y3=p3.y;
    // Based on solving linear system
    const a = x2 - x1; const b = y2 - y1;
    const c = x3 - x1; const d = y3 - y1;
    const e = (a*(x1+x2) + b*(y1+y2)) / 2.0;
    const f = (c*(x1+x3) + d*(y1+y3)) / 2.0;
    const det = a*d - b*c;
    if (Math.abs(det) < 1e-9) {
      // nearly collinear; ignore
      circle = null; return;
    }
    const cx = (d*e - b*f) / det;
    const cy = (-c*e + a*f) / det;
    const r = Math.hypot(cx - x1, cy - y1);
    circle = {cx,cy,r};

    // after computing, optionally snap points to exact circle circumference? We will not move points but we can show circle
    updateInfo();
  }

  // initial setup
  function init() {
    // set initial canvas size
    const wrapper = canvas.parentElement;
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    resize();
    // prevent context menu to help right-click use-case
    canvas.addEventListener('mousedown', (e)=>{ if(e.button===2) e.preventDefault(); });
  }

  init();
})();
</script>
</body>
</html>
