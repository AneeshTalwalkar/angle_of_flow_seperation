<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sphere circumference picker — click 3 points</title>
<style>
  :root{--bg:#0f172a;--card:#0b1220;--accent:#60a5fa;--muted:#94a3b8}
  html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial}
  body{display:flex;gap:12px;background:linear-gradient(180deg,#071028 0%, #071b2c 100%);color:#e6eef8;padding:12px}
  .sidebar{width:320px;min-width:240px;background:var(--card);border-radius:10px;padding:14px;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
  .main{flex:1;display:flex;align-items:stretch}
  canvas{background:#111827;border-radius:8px;display:block;width:100%;height:100%;cursor:crosshair}
  h1{font-size:16px;margin:0 0 8px}
  label{display:block;margin-bottom:8px}
  input[type=file]{display:block}
  button{background:transparent;border:1px solid rgba(255,255,255,0.08);color:var(--accent);padding:8px 10px;border-radius:6px;margin:6px 6px 6px 0}
  .muted{color:var(--muted);font-size:13px}
  .points{margin-top:8px}
  .point-row{display:flex;justify-content:space-between;padding:6px 4px;border-radius:6px}
  .controls{margin-top:12px}
  .hint{font-size:13px;color:var(--muted);margin-top:8px}
  .stat{margin-top:10px;padding:8px;border-radius:6px;background:rgba(255,255,255,0.02)}
</style>
</head>
<body>
  <div class="sidebar">
    <h1>Sphere circumference picker</h1>
    <div class="muted">Upload, paste (Ctrl+V) or drag an image. Zoom/pan to click precisely.</div>

    <label>Image <input id="file" type="file" accept="image/*"></label>
    <div class="controls">
      <button id="undo">Undo last point</button>
      <button id="clear">Clear points</button>
      <button id="resetView">Reset view</button>
      <button id="download">Download annotated image</button>
      <button id="copyAnnotated">Copy annotated image</button>
    </div>

    <div class="points">
      <div class="muted">Clicked points (image pixels):</div>
      <div id="list"></div>
    </div>

    <div class="stat">Center: <span id="center">—</span></div>
    <div class="stat">Radius: <span id="radius">—</span></div>
    <div class="stat">Angle: <b id="angle">—</b></div>

    <div class="hint">Left-click = place point • Right-click = undo • Wheel = zoom • Space-drag = pan • Ctrl+V to paste image</div>
  </div>

  <div class="main">
    <canvas id="canvas"></canvas>
  </div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const fileInput = document.getElementById('file');
  const listDiv = document.getElementById('list');
  const undoBtn = document.getElementById('undo');
  const clearBtn = document.getElementById('clear');
  const resetViewBtn = document.getElementById('resetView');
  const downloadBtn = document.getElementById('download');
  const copyAnnotatedBtn = document.getElementById('copyAnnotated');
  const centerEl = document.getElementById('center');
  const radiusEl = document.getElementById('radius');
  const angleEl = document.getElementById('angle');

  let img = new Image();
  let imgLoaded = false;

  let scale = 1;
  let tx = 0;
  let ty = 0;
  const MIN_SCALE = 0.05;
  const MAX_SCALE = 40;

  let points = [];
  let circle = null;

  function fitCanvasToScreen(){
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.max(300, rect.width * dpr);
    canvas.height = Math.max(200, rect.height * dpr);
  }

  function resize(){ fitCanvasToScreen(); render(); }
  window.addEventListener('resize', resize);

  function loadImageFromBlob(blob){
    const url = URL.createObjectURL(blob);
    const tmp = new Image();
    tmp.onload = () => {
      img = tmp; imgLoaded = true;
      const rect = canvas.getBoundingClientRect();
      scale = Math.min(rect.width / img.width, rect.height / img.height);
      if (!isFinite(scale) || scale <= 0) scale = 1;
      tx = (rect.width - img.width * scale) / 2;
      ty = (rect.height - img.height * scale) / 2;
      points = [];
      circle = null;
      updateInfo();
      render();
    };
    tmp.src = url;
  }

  fileInput.addEventListener('change', e => { const f = e.target.files && e.target.files[0]; if(f) loadImageFromBlob(f); });
  window.addEventListener('dragover', e => e.preventDefault());
  window.addEventListener('drop', e => { e.preventDefault(); const f = e.dataTransfer.files && e.dataTransfer.files[0]; if(f && f.type.startsWith('image/')) loadImageFromBlob(f); });

  window.addEventListener('paste', e => {
    const items = e.clipboardData && e.clipboardData.items;
    if (!items) return;
    for (let i=0;i<items.length;i++){
      const it = items[i];
      if (it.type && it.type.startsWith('image')){
        const file = it.getAsFile();
        if (file) { loadImageFromBlob(file); return; }
      }
    }
    const text = e.clipboardData.getData('text/plain');
    try { if (text && text.startsWith('data:image')){ fetch(text).then(res=>res.blob()).then(loadImageFromBlob).catch(()=>{}); } } catch (err){}
  });

  function clientToCanvas(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    return { x:(clientX - rect.left) * dpr, y:(clientY - rect.top) * dpr };
  }
  function canvasToImage(cx, cy){
    const dpr = window.devicePixelRatio || 1;
    const ix = (cx/dpr - tx) / scale;
    const iy = (cy/dpr - ty) / scale;
    return {x: ix, y: iy};
  }
  function imageToCanvas(ix, iy){
    const dpr = window.devicePixelRatio || 1;
    return { x:(ix*scale + tx) * dpr, y:(iy*scale + ty) * dpr };
  }

  function render(){
    fitCanvasToScreen();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = '#0b1220'; ctx.fillRect(0,0,canvas.width,canvas.height);
    if(!imgLoaded) return;

    const dpr = window.devicePixelRatio || 1;
    ctx.setTransform(scale*dpr,0,0,scale*dpr,tx*dpr,ty*dpr);
    ctx.imageSmoothingEnabled = true;
    ctx.drawImage(img,0,0);

    if(circle){
      ctx.save();
      ctx.strokeStyle = 'rgba(96,165,250,0.95)';
      ctx.lineWidth = Math.max(2/scale, 0.5);
      ctx.beginPath(); ctx.arc(circle.cx, circle.cy, circle.r, 0, Math.PI*2); ctx.stroke();
      ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(circle.cx, circle.cy, Math.max(4/scale,2/scale), 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }

    if(circle && points.length>=1){ ctx.save(); ctx.strokeStyle='rgba(16,185,129,0.95)'; ctx.lineWidth = Math.max(2/scale,0.5); ctx.beginPath(); ctx.moveTo(circle.cx,circle.cy); ctx.lineTo(points[0].x,points[0].y); ctx.stroke(); ctx.restore(); }
    if(circle && points.length>=2){ ctx.save(); ctx.strokeStyle='rgba(59,130,246,0.95)'; ctx.lineWidth = Math.max(2/scale,0.5); ctx.beginPath(); ctx.moveTo(circle.cx,circle.cy); ctx.lineTo(points[1].x,points[1].y); ctx.stroke(); ctx.restore(); }

    // draw points with labels
    points.forEach((p,i)=>{
      ctx.save();
      const col = ['#10b981','#3b82f6','#f97316'][i] || 'white';
      ctx.fillStyle = col;
      const r = Math.max(7/scale, 4/scale);
      ctx.beginPath(); ctx.arc(p.x,p.y,r,0,Math.PI*2); ctx.fill();

      // label background
      ctx.fillStyle = 'white';
      ctx.font = `${Math.max(16/scale,10/scale)}px Inter`;
      const label = String(i+1);
      const tw = ctx.measureText(label).width;
      const th = Math.max(16/scale,10/scale);
      ctx.fillRect(p.x + r + 4/scale, p.y - th + 4/scale, tw + 6/scale, th);

      // label text
      ctx.fillStyle = 'black';
      ctx.fillText(label, p.x + r + 7/scale, p.y + 4/scale);

      ctx.restore();
    });
  }

  let isPanning=false, lastPan=null;

  canvas.addEventListener('wheel', e => {
    if(!imgLoaded) return;
    e.preventDefault();
    const pos = clientToCanvas(e.clientX,e.clientY);
    const before = canvasToImage(pos.x,pos.y);
    const zoom = Math.exp(-e.deltaY*0.0015);
    scale = Math.min(MAX_SCALE, Math.max(MIN_SCALE, scale*zoom));
    tx = pos.x/(window.devicePixelRatio||1) - scale*before.x;
    ty = pos.y/(window.devicePixelRatio||1) - scale*before.y;
    render();
  }, {passive:false});

  canvas.addEventListener('pointerdown', e => {
    if(!imgLoaded) return;
    canvas.setPointerCapture(e.pointerId);
    if(e.button===1 || e.getModifierState && e.getModifierState('Space')){ isPanning=true; lastPan={x:e.clientX,y:e.clientY}; return; }
    if(e.button===0){
      const pos = clientToCanvas(e.clientX,e.clientY);
      const ip = canvasToImage(pos.x,pos.y);
      ip.x = Math.max(0,Math.min(img.width, ip.x)); ip.y = Math.max(0,Math.min(img.height, ip.y));
      points.push(ip);
      if(points.length>3) points = points.slice(-3);
      computeCircle(); updateInfo(); render();
    }
  });

  canvas.addEventListener('pointermove', e => {
    if(isPanning && lastPan){
      const dx = e.clientX - lastPan.x; const dy = e.clientY - lastPan.y;
      tx += dx / (window.devicePixelRatio||1); ty += dy / (window.devicePixelRatio||1);
      lastPan = {x:e.clientX,y:e.clientY}; render();
    }
  });
  canvas.addEventListener('pointerup', e => { canvas.releasePointerCapture && canvas.releasePointerCapture(e.pointerId); isPanning=false; lastPan=null; });
  canvas.addEventListener('contextmenu', e => { e.preventDefault(); if(!imgLoaded) return; points.pop(); computeCircle(); updateInfo(); render(); });

  undoBtn.addEventListener('click', ()=>{ points.pop(); computeCircle(); updateInfo(); render(); });
  clearBtn.addEventListener('click', ()=>{ points=[]; circle=null; updateInfo(); render(); });
  resetViewBtn.addEventListener('click', ()=>{ if(!imgLoaded) return; const rect = canvas.getBoundingClientRect(); scale = Math.min(rect.width / img.width, rect.height / img.height) || 1; tx = (rect.width - img.width * scale)/2; ty = (rect.height - img.height * scale)/2; render(); });

  downloadBtn.addEventListener('click', ()=>{
    if(!imgLoaded) return;
    const out = document.createElement('canvas');
    out.width = img.width; out.height = img.height;
    const oc = out.getContext('2d');
    // draw base image
    oc.drawImage(img,0,0);

    // draw circle, center marker and radius lines in image coordinates
    if(circle){
      oc.save();
      oc.strokeStyle='rgba(96,165,250,1)';
      oc.lineWidth = Math.max(3, 3);
      oc.beginPath(); oc.arc(circle.cx,circle.cy,circle.r,0,Math.PI*2); oc.stroke();
      // center marker
      oc.fillStyle = 'white'; oc.beginPath(); oc.arc(circle.cx,circle.cy,8,0,Math.PI*2); oc.fill();
      oc.restore();

      // radius lines to point 1 and 2 if present
      if(points.length>=1){ oc.save(); oc.strokeStyle='rgba(16,185,129,0.95)'; oc.lineWidth=3; oc.beginPath(); oc.moveTo(circle.cx,circle.cy); oc.lineTo(points[0].x,points[0].y); oc.stroke(); oc.restore(); }
      if(points.length>=2){ oc.save(); oc.strokeStyle='rgba(59,130,246,0.95)'; oc.lineWidth=3; oc.beginPath(); oc.moveTo(circle.cx,circle.cy); oc.lineTo(points[1].x,points[1].y); oc.stroke(); oc.restore(); }
    }

    // draw labeled points (match on-screen style)
    points.forEach((p,i)=>{
      const cols = ['#10b981','#3b82f6','#f97316'];
      const col = cols[i] || '#ffffff';
      // point fill
      oc.fillStyle = col; oc.beginPath(); oc.arc(p.x,p.y,10,0,Math.PI*2); oc.fill();
      // label background
      const label = String(i+1);
      oc.font = '18px Inter, Arial';
      const tw = oc.measureText(label).width;
      const th = 18;
      const lx = p.x + 12;
      const ly = p.y - th/2;
      oc.fillStyle = 'white'; oc.fillRect(lx, ly, tw + 8, th + 4);
      // label text
      oc.fillStyle = 'black'; oc.fillText(label, lx + 6, ly + th - 4);
    });

    const url = out.toDataURL('image/png');
    const a = document.createElement('a'); a.href = url; a.download = 'annotated.png'; a.click();
  });

  copyAnnotatedBtn.addEventListener('click', async ()=>{
    if(!imgLoaded) return alert('No image');
    try{
      const out = document.createElement('canvas'); out.width = img.width; out.height = img.height; const oc = out.getContext('2d');
      oc.drawImage(img,0,0);

      if(circle){
        oc.save();
        oc.strokeStyle='rgba(96,165,250,1)'; oc.lineWidth = Math.max(3,3); oc.beginPath(); oc.arc(circle.cx,circle.cy,circle.r,0,Math.PI*2); oc.stroke();
        oc.fillStyle='white'; oc.beginPath(); oc.arc(circle.cx,circle.cy,8,0,Math.PI*2); oc.fill(); oc.restore();
        if(points.length>=1){ oc.save(); oc.strokeStyle='rgba(16,185,129,0.95)'; oc.lineWidth=3; oc.beginPath(); oc.moveTo(circle.cx,circle.cy); oc.lineTo(points[0].x,points[0].y); oc.stroke(); oc.restore(); }
        if(points.length>=2){ oc.save(); oc.strokeStyle='rgba(59,130,246,0.95)'; oc.lineWidth=3; oc.beginPath(); oc.moveTo(circle.cx,circle.cy); oc.lineTo(points[1].x,points[1].y); oc.stroke(); oc.restore(); }
      }

      points.forEach((p,i)=>{
        const cols = ['#10b981','#3b82f6','#f97316'];
        const col = cols[i] || '#ffffff';
        oc.fillStyle = col; oc.beginPath(); oc.arc(p.x,p.y,10,0,Math.PI*2); oc.fill();
        const label = String(i+1);
        oc.font = '18px Inter, Arial';
        const tw = oc.measureText(label).width; const th = 18;
        const lx = p.x + 12; const ly = p.y - th/2;
        oc.fillStyle = 'white'; oc.fillRect(lx, ly, tw + 8, th + 4);
        oc.fillStyle = 'black'; oc.fillText(label, lx + 6, ly + th - 4);
      });

      out.toBlob(async blob => {
        try{
          await navigator.clipboard.write([new ClipboardItem({ [blob.type]: blob })]);
          alert('Annotated image copied to clipboard');
        }catch(err){
          alert('Copy failed: '+err);
        }
      });
    }catch(err){ alert('Copy failed: '+err); }
  });

  function updateInfo(){ listDiv.innerHTML=''; points.forEach((p,i)=>{ const row=document.createElement('div'); row.className='point-row'; row.innerHTML = `<div>Point ${i+1}</div><div class='muted'>(${p.x.toFixed(1)}, ${p.y.toFixed(1)})</div>`; listDiv.appendChild(row); });
    if(circle){ centerEl.textContent = `${circle.cx.toFixed(2)}, ${circle.cy.toFixed(2)}`; radiusEl.textContent = `${circle.r.toFixed(2)} px`; }
    else { centerEl.textContent = '—'; radiusEl.textContent = '—'; }
    if(circle && points.length>=2){ const v1={x:points[0].x-circle.cx,y:points[0].y-circle.cy}; const v2={x:points[1].x-circle.cx,y:points[1].y-circle.cy}; const dot = v1.x*v2.x+v1.y*v2.y; const m1=Math.hypot(v1.x,v1.y); const m2=Math.hypot(v2.x,v2.y); const cos = Math.max(-1, Math.min(1, dot/(m1*m2))); const ang = Math.acos(cos) * 180/Math.PI; angleEl.textContent = `${ang.toFixed(3)}°`; } else angleEl.textContent='—'; }

  function computeCircle(){ circle=null; if(points.length<3) return; const [p1,p2,p3]=points.slice(0,3); const x1=p1.x,y1=p1.y,x2=p2.x,y2=p2.y,x3=p3.x,y3=p3.y; const a=x2-x1, b=y2-y1, c=x3-x1, d=y3-y1; const e=(a*(x1+x2)+b*(y1+y2))/2; const f=(c*(x1+x3)+d*(y1+y3))/2; const det=a*d-b*c; if(Math.abs(det)<1e-9){ circle=null; return; } const cx=(d*e - b*f)/det; const cy=(-c*e + a*f)/det; const r=Math.hypot(cx-x1, cy-y1); circle={cx,cy,r}; updateInfo(); }

  function init(){ canvas.style.width = '100%'; canvas.style.height = '100%'; resize(); document.addEventListener('keydown', e=>{ if(e.code==='Space') e.preventDefault(); }); }
  init();
})();
</script>
</body>
</html>
